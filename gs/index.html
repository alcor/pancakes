<!DOCTYPE html>
<html>
<head>
<title></title>
<base target="_self">
<?!=HtmlService.createHtmlOutputFromFile('gs/css').getContent()?>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js" doNotEncode></script>
</head>
<body>
<form id="new" onsubmit="submitNewToc(); return false;">
  <input id="new-url" type="text" placeholder="Paste a Google Docs Link">
  <div style="display:flex">
    <input type="button" onclick="document.body.classList.remove('new')" value="Cancel">
    <input type="submit" value="Create">
  </div>
</form>
<nav>
  <div id="menu-button" class="menu-button" onclick="this.classList.toggle('open'); event.stopPropagation();">
    <div class="material-icons">more_horiz</div>
    <div class="menu-contents">
      <div class="menu-item action-edit-doc" onclick="editDoc(event)">Edit Document</div>
      <div class="menu-item action-edit-toc" onclick="editToc(event)">Edit Index</div>
      <!-- <div class="menu-item action-fullscreen" onclick="fullscreen()">Fullscreen</div> -->
      <div class="menu-item action-new-toc" onclick="createNewToc()">Create New...</div>
    </div>
  </div>
  <div id="toc" class="toc-content"></div>
</nav>
<main id="doc" class="content"></main>
<iframe id="doc-frame" class="content" name="frame" src=""></iframe>
</body>

<script>

  const URL_REWRITES = [
    { name: "Figma",
      re: /^https:\/\/([^\/\.]+\.)?figma.com\/(?<mode>file|proto)\/(?<id>[0-9a-zA-Z]{22,128})(?:\/.*)?$/,
      sub: "https://www.figma.com/embed?embed_host=astra&url=$&"},
    { name: "YouTube",
      re: /https:\/\/(youtu.be|www.youtube.com)\/(watch\?v=)?(?<id>\w+)([?&](?<params>t=.*)?)?/,
      sub: "https://www.youtube.com/embed/$<id>?autoplay=1&$<params>"}
  ]

  const docsRE = /https:\/\/docs.google.com\/(?<type>document|spreadsheets|presentation)\/d\/(?<id>[^\/]*)\/?(?<mode>[^\n#]*)(#(?<hash>.*))?/
  const figmaRE = /^https:\/\/([^\/\.]+\.)?figma.com\/(?<mode>file|proto)\/(?<id>[0-9a-zA-Z]{22,128})(?:\/.*)?$/

  let tocId = '<?= tocId ?>'
  let docId = '<?= docId ?>';
  let globalMode = <?= mode ?>;
  let hash;

  let tocData = <?!=JSON.stringify(tocData)?>;
  let docData = <?!=JSON.stringify(docData)?>;

  if (docData && docData != {} && !docData.error) {
    localStorage.setItem(doc.id, JSON.stringify({ts:new Date().getTime(), val:docData}));
  }

  google.script.url.getLocation(function(location) {
    hash = location.hash
  });


function loadDocInline(doc, isToc = false, ignoreCache = false) {
  window.scrollTo({ top: 0, behavior: 'smooth' });

  let hasOldData = false;
  if (!ignoreCache) {
    if (docData && doc.id == docData.documentId) {
      console.log("💾 Rendering Doc Data", doc.id)
      renderContent(docData);
      docData = undefined;
      return;
    } 
    
    let cache = localStorage.getItem(doc.id)
    if (cache) {
      console.log("💾 Rendering Cache", doc.id)
      let data = JSON.parse(cache);

      if (data.ts) {
        renderContent(data.val, isToc);
        if (new Date().getTime() - data.ts < 25 * 60 * 1000) {
          return;
        }
        hasOldData = true;
      } 
    }
  }

  console.debug("⬇️ Fetching:", doc.id)
  document.body.classList.add(hasOldData ? "outofdate" :"loading");
  google.script.run
  .withFailureHandler((e) => console.log("ERROR", e))
  .withSuccessHandler(gotData.bind(null, doc, isToc)).getData(doc.id, ignoreCache);

}

// Parse data
function gotData(doc, isToc, response) {
  let data = JSON.parse(response)
  renderContent(data, isToc)
  document.body.classList.remove("loading");
  document.body.classList.remove("outofdate");
  if (!isToc && !data.error) {
    localStorage.setItem(doc.id, JSON.stringify({ts:new Date().getTime(), val:data}));
  }
}


// Utility Functions


// Core create-element function
var m = function createElement(type, attrs, ...children) {
  var types = type.split(".")
  var node = document.createElement(types.shift());

  for (var prop in attrs) {
    if (!attrs.hasOwnProperty(prop)) continue;
    if (attrs[prop] != undefined) node[prop] = attrs[prop];
  }

  for (let type of types) node.classList.add(type);
  
  function append(child) {
    if (Array.isArray(child)) return child.forEach(append); 
    if (typeof child == 'string') child = document.createTextNode(child);
    if (child) node.appendChild(child);
  }
  
  children.forEach(append);
  return node;
}




const TYPE_TO_SELECTOR = {
  TITLE: 'div.title',
  SUBTITLE: 'div.subtitle',
  NORMAL_TEXT: 'p'
}

function typeToSelector(type) {
  return TYPE_TO_SELECTOR[type] ||  (type.charAt(0) + type.charAt(type.length-1))
}

function colorForObject(rgb) {
  if (rgb) return `rgb(${rgb.red * 255},${rgb.green * 255},${rgb.blue * 255})`;
}

// CSS Creation

function cssForDoc(doc, isToc) {
  let css = []

  let color = colorForObject(doc.documentStyle?.background?.color?.color?.rgbColor)
  if (color) css.push((isToc ? 'nav' : 'main')  + `{background-color:${color}}`);

  if (!isToc) {
    let docStyle = doc.documentStyle;
    css.push(`.doc-inner {max-width:${docStyle.pageSize.width.magnitude - docStyle.marginLeft.magnitude - docStyle.marginRight.magnitude}pt;}`);
  }

  for (let info of doc.namedStyles?.styles) {
    let type = info.namedStyleType;
    let selector = typeToSelector(type);
    
    let declarations = [];
    if (info.textStyle.fontSize) {
      declarations.push(`font-size:${info.textStyle.fontSize.magnitude}${info.textStyle.fontSize.unit};`);
    }
    if (info.textStyle.weightedFontFamily?.fontFamily) {
      declarations.push(`font-family:${info.textStyle.weightedFontFamily.fontFamily}, system-ui, sans-serif;`);
      maybeLoadFont(info.textStyle.weightedFontFamily.fontFamily);
    }
    if (info.textStyle.weightedFontFamily?.weight) {
      declarations.push(`font-weight:${info.textStyle.weightedFontFamily.weight};`);
    }
    if (info.textStyle.foregroundColor) {
      declarations.push(`color:${colorForObject(info.textStyle.foregroundColor.color.rgbColor)};`);
    }
    if (info.textStyle.bold) {
      declarations.push(`font-weight:bold;`);
    }
    if (declarations.length) {
      css.push(`main ${selector}{${declarations.join("")}}`);
    }
  }
  return css.join("");
}


// Element Creation 

function elementForParagraph(p, doc) {
    if (!p) return null;
    let selector = typeToSelector(p.paragraphStyle.namedStyleType); 

    let attrs = {}
    let style = p.paragraphStyle;

    if (!style.headingId && p.bullet && !doc.isToc) {
      selector = 'p.li';
      let level = p.bullet.nestingLevel || 0;
      selector += ".bullet-" + level;
    };
    if (p.table) console.log("p.table", p.table)


    if (style.shading && !doc.isToc) {
      let color = colorForObject(style.shading?.backgroundColor?.color?.rgbColor);
      if (color && color != "rgb(255,255,255)") attrs.style = "background-color:" + color +"; padding: 1em; ";
    }

    if (p.paragraphStyle?.headingId) attrs.id = p.paragraphStyle.headingId;

    return m(selector, attrs, 
      p.positionedObjectIds?.map(o => elementForObject(doc.positionedObjects[o], doc)),
      p.elements?.map(e => elementForElement(e, doc))
    )
}

function elementForElement(e, doc) {
  if (e.inlineObjectElement) {
    return elementForObject(doc.inlineObjects[e.inlineObjectElement.inlineObjectId], doc);
  }
  if (e.horizontalRule) {
    return m('hr');
  }
  
  let text = e.textRun?.content
  if (!text) {
    return null;
  }
  let el = text;
  let params = {}
  let runStyle = e.textRun?.textStyle
  if (!doc.isToc) {
    if (runStyle.underline) el = m('u',{}, el);
    if (runStyle.italic) el = m('i',{}, el);
    if (runStyle.bold) el = m('b',{}, el);
    if (runStyle.strikethrough) el = m('strike',{}, el);
    if (runStyle.baselineOffset == "SUPERSCRIPT") el = m('sub',{}, el) ;
    if (runStyle.baselineOffset == "SUBSCRIPT") el = m('sup',{}, el) ;
    if (runStyle.foregroundColor) el = m('span', {style:"color:" + colorForObject(runStyle.foregroundColor.color.rgbColor)}, el);
  } else {
    // el = el.trim();
  }
  
  if (runStyle.link) {
    let url = runStyle.link.url
    if (url) {
      let id = idForUrl(url)
      let external = !urlIsEmbeddable(url);
      el = m('a' + (external ? ".external-link" : ".embedded-link"), {id, href:url }, el);
    } else {
      el = m('a.heading-link', {href: "#" + runStyle.link.headingId }, el);
    }
  }
  return el;
}

let ERROR_DESCRIPTIONS = {
  403: "This document may not be shared with others"
}
function elementForObject(info, doc) {
  info = info.positionedObjectProperties || info.inlineObjectProperties;
  if (!info) return;

  let object = info.embeddedObject
  let styles = [];
  let position = info.positioning;
  if (pos = info.positioning) {
    if (pos.layout == "WRAP_TEXT") {
      styles.push(`float:right`);
    } else if (pos.layout == "BREAK_LEFT_RIGHT") {
      styles.push(`display:block`);
    } else {
      if (pos.layout == "IN_FRONT_OF_TEXT") styles.push(`position:absolute; z-index:1;`);
      if (pos.layout == "BEHIND_TEXT") styles.push(`position:absolute; z-index:-1`);
      if (pos.leftOffset) styles.push(`margin-left:${pos.leftOffset?.magnitude}px;`);
      if (pos.topOffset) styles.push(`margin-top:${pos.topOffset?.magnitude}px;`);
    }
  } else {
    styles.push(`display:inline-block`);
  }

  let w = object.size.width.magnitude;
  let h = object.size.height.magnitude;

  // TODO: This is incorrect because offsets should be based on the original image width, which the API does not provide.
  // https://developers.google.com/docs/api/reference/rest/v1/CropProperties

  let crop = object.imageProperties.cropProperties;
  let t = 0 - (crop.offsetTop || 0);
  let l = 0 - (crop.offsetLeft || 0);
  let r = 1 + (crop.offsetRight || 0);
  let b = 1 + (crop.offsetBottom || 0);

  styles.push(`width:${w}px`)
  styles.push(`height:${h}px`)
  if (!doc.isToc) styles.push(`margin:1em`)
  styles.push(`background-position:${l * w}px ${t * h}px`)  
  styles.push(`background-size:${(r - l) * w}px ${(b - t) * h}px`)  
  //console.log(styles.join("\n"), crop)
  styles.push(`background-image:url(${object.imageProperties?.contentUri})`)  

  return m('div.img', {style:styles.join(";")})
}


function elementForTable(table, doc) {
  let rows = table.tableRows.map(tr => {
    if (tr.tableRowStyle?.minRowHeight?.magnitude < 0.08) return null; // 0.001 min row height is used to hide tables from view mode
    console.log("Row" , tr.tableRowStyle?.minRowHeight?.magnitude, undefined < 0.08)
    let cells = tr.tableCells.map(td => {
      let style = td.tableCellStyle;
      let attrs = {
        colSpan: style.columnSpan,
        rowSpan: style.rowSpan,
      }
      if (style.backgroundColor?.color) attrs.style = "background-color:" + colorForObject(style.backgroundColor?.color?.rgbColor);

      let paragraphEls = td.content.map(c => elementForParagraph(c.paragraph, doc));
      return m('td',attrs, paragraphEls)
    })
    return m('tr', {}, cells);
  })
  return m('table', {}, rows);
}

function expandDocUrl(url) {
  if (!url.startsWith("http")) {
    url = urlForDocInfo({id:url}, true)
  }
  return url;
}

function renderContent(doc, isToc) {
  
  // Create elements for document content
  let body = doc.body
  let docType = isToc ? 'toc' : 'doc';
  console.log("📐 Rendering", docType, [doc.documentId, doc])
  
  if (isToc) doc.isToc = true;

  let children = [];
  let rootEl = m('div.' + docType + '-inner', {})
  let headingStack = [];
  let currentHeader;

  if (doc.error) {
    rootEl.appendChild(m("div.error", {},
      m('b', {}, ERROR_DESCRIPTIONS[doc.error.details.code]),
      m('br'),
      m('p', {}, doc.error.details.message),
      m('i', {}, doc.error.name, " ",  doc.error.details.code.toString())
      ));
  } else {
    for (let c of doc.body.content) {
      let el;
      if (c.paragraph) {      
        el = elementForParagraph(c.paragraph, doc);
      } else if (c.table) {
        el = elementForTable(c.table, doc);
      }

      let headingId = c.paragraph?.paragraphStyle?.headingId
      let depth = parseInt(c.paragraph?.paragraphStyle?.namedStyleType?.slice(-1));

      if (headingId) {
        let index = headingStack.findIndex(h => h.depth >= depth );
        if (index != -1) headingStack.splice(index);
      }

      let parent = headingStack.length ? headingStack[headingStack.length - 1].el : rootEl;
    
      if (headingId) {
        if (depth) {
          let hasBullet = c.paragraph?.bullet;
          el.classList.add("heading")
          let headingChildren = m('div.heading-children', {depth:depth, id:headingId + "-children"});   

          let containerClasses = ['div', 'heading-container'];

          if (hasBullet) containerClasses.push('collapsed')
          containerClasses.push("heading-" +depth);
          el = m(containerClasses.join('.'), {id: headingId + "-container"}, el, headingChildren)
          headingStack.push({depth: depth, el: headingChildren})
        }
      }

      if (el) parent.appendChild(el)
    }


    // Create CSS rules for document styles
    let css = cssForDoc(doc, isToc) // isToc ? cssForDoc(doc) : undefined;
    if (css && css.length) {
        rootEl.appendChild(m('style', {type:'text/css'}, css))
    }
  }

  let docEl = document.getElementById(docType);
  while (docEl.firstChild) docEl.removeChild(docEl.lastChild);



  docEl.appendChild(rootEl)


  if (isToc) {
    let url;
    document.title = doc.title;
    if (docId.length) {
      url = expandDocUrl(docId)
    } else {
      let links = docEl.querySelectorAll("a[href]");
      for (let link of links) {
        if (urlIsEmbeddable(link.href)) {
          link.classList.add('selected');
          url = link.href
          break;
        }
      }
    
    }
    
    if (url) displayDoc(url);
  } else {
    google.script.url.getLocation(function(location) {
      hash = location.hash
      if (hash.length) {
        console.log("Scrolling to", hash)
        scrollToHeader(hash)
      }
    });
  }
}

function scrollToHeader(hash) {
  if (!hash || !hash.length) return;
  let el = document.getElementById(hash);
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start'});
  //TODO: https://stackoverflow.com/questions/48634459/scrollintoview-block-vs-inline/48635751#48635751
}



function docInfoForUrl(url) {
  let match = url.match(docsRE)
  return match?.groups;
}

function idForUrl(url) {
  if (url) {
    let info = docInfoForUrl(url);
    if (info && info.type == 'document' && info.mode != 'preview') return info.id;
  }
  return url;
}

function urlForDocInfo(doc) {
  let url = "https://docs.google.com/" + (doc.type || 'document') + "/d/";
  url += doc.id + "/" + (doc.mode || 'edit');
  if (doc.hash) url += "#" + doc.hash;
  return url;
  //return `https://docs.google.com/document/d/${doc.id}/${doc.mode}` //|| ''}` + ${doc.header ? '#header=' + header : ''}
}

function createNewToc() {
  document.body.classList.add("new");
  document.getElementById("new-url").focus()
}

function submitNewToc() {
  let link = document.getElementById("new-url").value
  let docInfo = link.startsWith("http") ? docInfoForUrl(link) : {id:link};
  if (docInfo.id) {
    tocId = docInfo.id;
    docId = '';
    docData = {};
    tocData = {};
    pushHistoryState();
    loadDocInline({id: tocId}, true, true)
  }
  document.body.classList.remove("new");
}


document.addEventListener('click', function(e) {
  document.getElementById('menu-button').classList.remove('open');
  let a = e.target.closest('a');
  if (a) {
    let url = a.getAttribute('href');
    if (url) {
      displayDoc(url, e.altKey, true, e.shiftKey)
    }
    e.preventDefault();
    // e.stopPropogation();
    return false;
  } else {
    if (e.target.id) {
      document.getElementById(e.target.id + "-container").classList.toggle('collapsed')
    }

  }
})

function editToc(e) {
  let url = "https://docs.google.com/document/d/" + tocId + "/edit";
  if (e.metaKey || e.ctrlKey) {
    window.open(url, '_blank');
  } else {
    displayDoc(url, true)
  }
}

function editDoc(e) {
  let url = docId;
  if (!url.startsWith("http")) url = urlForDocInfo({id:docId}, true)

  if (e.metaKey || e.ctrlKey) {
    window.open(url, '_blank');
  } else {
    displayDoc(url, true)
  }
}

function fullscreen() {
  let el = document.getElementById('doc-frame');
  el.requestFullscreen();
}

function updateTocSelection(url) {
  let id = idForUrl(url); 
  docId = id;

  let links = document.querySelectorAll("nav a")
  for (let link of links) {
    link.classList.toggle('selected', link.id == id)
  }
}

function urlIsEmbeddable(url) {
  if (url.indexOf('docs.google.com') > 0) return true;
  for (let rewrite of URL_REWRITES) {
    if (url.match(rewrite.re)) return true;
  }
  return false;
}

function displayDoc(url, editMode = false, updateHistory = true, ignoreCache = false) {
  console.debug("🖼 Displaying", url)

  if (url.startsWith("#")) return scrollToHeader(url.slice(1))

  let target = 'frame';
  let googleDoc = docInfoForUrl(url);  

  if (googleDoc) {
    if (globalMode == 'edit') editMode = true;
    if (editMode) {
      googleDoc.mode = 'edit';
    } else if (googleDoc.type == "document" && googleDoc.mode != "preview") {
      target = 'inline';
    } else {
      googleDoc.mode = 'preview';
    }
    url = urlForDocInfo(googleDoc)
  } else {
    let rewrite = rewriteUrl(url);
    if (rewrite) {
      url = rewrite;
    } else {
      target = 'blank';
    }
  }

  if (target == 'blank') {
      console.debug("🌐 Opening Tab:", url)
      window.open(url, '_blank');
  } else {
    let frame = document.getElementById('doc-frame');
    if (target == 'inline') {
      loadDocInline(googleDoc, false, ignoreCache);
      document.body.classList.remove('frame');
      frame.src = 'about:blank';
    } else if (target == 'frame') {
      console.debug("🌐 Framing:", url)
      frame.src = url;
      document.body.classList.add('frame');
    }
    updateTocSelection(url, updateHistory);
    if (updateHistory) {
      pushHistoryState()
    }
  }
}

function pushHistoryState() {
  let attrs = {toc:tocId};
  console.log("toc", attrs)
  if (docId && docId.length) attrs.doc = docId;
  console.log("toc", attrs, tocId)
  google.script.history.push({'timestamp': new Date().getTime(), doc:docId}, attrs);
  attrs.title = document.title;
  window.top.postMessage(attrs, '*')
}

function rewriteUrl(url) {
  for (let rewrite of URL_REWRITES) {
    console.log("rplace", url.replace(rewrite.re, rewrite.sub))
    let match =  url.match(rewrite.re)
    if (match) {
      return url.replace(rewrite.re, rewrite.sub)
    }
  }
}

let loadedFonts = {}  
var maybeLoadFont = function(font) {
  if (!font) return false;
  if (document.fonts.check("12px " + font )) return false; // No need to load font.
  if (loadedFonts[font] == 'loaded') return false;  // Font already loaded.
  if (loadedFonts[font] == 'loading') return true;  // Font is loading, just pretend we're loading it.
  

  loadedFonts[font] = 'loading';
  WebFont.load({
      google: { families: [font] },
      timeout: 2000,
      fontactive: function(family, fvd) {
        console.log('💼 Loaded ' + family);
        loadedFonts[family] = 'loaded';
      },
      fontinactive: function(family, fvd) {
        // Error loading font. Fallback
        loadedFonts[family] = 'loaded';
        console.log('⛔️ Failed to load ' + family);
      }
  });
  return true;
}

google.script.history.setChangeHandler(function (e) {
  let state = e.state;
  console.debug("🕘State Changed", state.doc, [e.state, e.parameter, e.location.hash]);
  displayDoc(expandDocUrl(state.doc))
});

if (!tocId.length) {
  loadDocInline({id: tocId}, true)
} else {
  renderContent(tocData, true)
}

</script>
</html>
