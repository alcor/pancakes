<!DOCTYPE html>
<html>
<head>
<title></title>
<base target="_self">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js" doNotEncode></script>
<style>

body {
  margin:0;
  font-family: "Roboto", system-ui;
  background-color: white;
  font-size: 14px;
  --padding-left: 32px;
  --sidebar-width: 240px;
}

body.outofdate #doc {
  opacity:0.89;
}

body.loading #doc {
  opacity:0.0;
  transition:opacity 2s cubic-bezier(0,1,0,1);
}

body.loading::before {
  content:'';
    border-radius: 50%;
    width: 24px;
    height: 24px;
    font-size: 10px;
    position: absolute;
    left: calc(50vw + var(--sidebar-width) / 2);
    top: 32px;
    margin-left:-12px;
    z-index:100;
    border-top: 2px solid rgba(0,0,0, 0.0);
    border-right: 2px solid rgba(0,0,0, 0.0);
    border-bottom: 2px solid rgba(0,0,0, 0.0);
    border-left: 2px solid #000000;
    -webkit-transform: translateZ(0);
    -ms-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-animation: spinner 1.1s infinite linear;
    animation: spinner 1.1s infinite linear;
}

@keyframes spinner {
  0%   { -webkit-transform: rotate(0deg);   transform: rotate(0deg); }
  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }
}

nav {
  width:var(--sidebar-width);
  height:100vh;
  overflow-y:auto;
  overflow-x:hidden;
  background:#fefefe;
  box-sizing:border-box;
  border-right:1px solid rgba(0,0,0,0.05);
  position:fixed;
  z-index:10;
  flex-basis:240px;
  flex:0 0 auto;
  user-select:none;
  box-sizing:border-box;
  background-clip: border-box;
}


main {
  min-height:100vh;
}

.heading {
  scroll-margin-top: 24px;
}

.heading-container.collapsed,
.heading:before
  {
  cursor:pointer;
}


nav .heading-container > .heading-children > :first-child {
  transition: margin-top 218ms cubic-bezier(0, 1, 1, 1);
}
nav .heading-container.collapsed > .heading-children > :first-child {
    transition: margin-top 218ms cubic-bezier(1, 0, 1, 1);
  margin-top:-120px;
}

nav::-webkit-scrollbar {
    background: transparent;
    width: 4px;
}

nav::-webkit-scrollbar-thumb {
    background: rgba(0,0,0,0.2);
}

nav .heading-children {
  overflow:hidden;
  transition: max-height 0s linear 0s; 
  max-height:100vh;
}

nav .heading-container.collapsed .heading-children{
  transition: max-height 0s linear 218ms;
  max-height:0px;
}

nav .heading {
  line-height:24px;
  margin-top:8px;
}

nav .heading-container.collapsable >.heading-children,
nav .heading-container.heading-3 >.heading-children,
nav .heading-container.heading-4 >.heading-children,
nav .heading-container.heading-5 >.heading-children,
nav .heading-container.heading-6 >.heading-children {
  margin-left:18px;
}
.collapsable > .heading:before {
  content:'chevron_right';
  float:left;
  margin-left:-1em;
  opacity:0.0;
  transition:transform 200ms;
  transform: rotate(90deg);
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-feature-settings: 'liga';
  -webkit-font-smoothing: antialiased;
}

.heading-container.collapsed .heading:before {
    transform: rotate(0deg);
    opacity:1.0;
}

.heading:hover:before {
  opacity:0.4

}

.title.heading:before {
  display:none;
}

img {
  max-width:100%;
}

.iframe-container {
  position: relative;

}
iframe.embed {
  border:none;
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
}

nav img {
  max-width:100%;
}

main img {
  margin:0.5em 1em 1em 1em;
}

.img, .iframe-container {
  background-repeat: no-repeat;
  background-size:cover;
}

.img.hero {
  margin-top:-10em;
  position:absolute;
  width:100%;
}

.img.lazy {
  background-image: none !important;
  background-color: rgba(0,0,0,0.05);
}

.doc-inner .img-container {
  max-width:100%;
  min-width:10px;
  display:inline-block;
}

.outofdate .doc-inner .img-container {
  background-color: rgba(0,0,0,0.03);
  border-radius: 6px;
}

.doc-inner .img-container.full-width {
  max-width:var(--content-width);
}

.img-container.hero {
  max-height: 50vh;
  overflow: hidden;
}

.doc-inner > p:first-child {
  margin:0;
}

.img-container.float-left {
  float:left;
  margin: 0em 1em 1em 0;
}

.img-container.float-right {
  float:right;
  margin: 0em 0em 1em 1em;
}


.header {
  height:104px;
}

p, li {
  line-height:150%;
  max-width: 42em;
}


/* .li {
  margin-block-start:0.5em;;
  margin-block-end:0.5em;;
}

.li:before {
  content:'•';
  display:inline-block;
  float:left;
  margin-left:-1.5em;
  opacity:0.75;
} */

/* .bullet-0 {
  padding-left:2em;
}
.bullet-1 {
  padding-left:4em;
}
.bullet-2 {
  padding-left:6em;
} */

li::marker {
  margin-left: 1em;
}
iframe#doc-frame {
  border:none;
  background-color:#fafafa;
  height:100vh;
}
.children {
  /* border:2px solid red; */
  /* padding:2px; */
}
.children.collapsed {
  max-height:0;
  overflow:hidden;
}

.children .children {
    border-color: green;
}

.children .children {
    border-color: blue;
}

body.frame #doc,
body:not(.frame) iframe#doc-frame {
  display:none;
}

.content {
  position:absolute;
  left:var(--sidebar-width);
  top:0;
  width:calc(100% - var(--sidebar-width));
  
}

nav .toc-inner p,
nav .toc-inner .title,
nav .toc-inner .subtitle,
nav .toc-inner .heading,
nav .toc-inner a {
  display:block;
  text-decoration:none;
  padding: 4px 24px 4px var(--padding-left);
  cursor:default;
}



nav .toc-inner .heading a,
nav .toc-inner p > a {
  margin: -4px -24px -4px -32px;
}

nav a {
  overflow:hidden;
  white-space:nowrap;
  text-overflow:ellipsis;
}
nav a:hover {
  background-color:rgba(0,0,0,0.03);
}

nav a.selected,
nav a.selected:hover {
  background-color:rgba(0,0,0,0.1);
}


nav .toc-inner a.external-link,
a.external-link {
  cursor:pointer;
}

nav .toc-inner a.external-link:not(.button):hover,
a.external-link:not(.button) {
  text-decoration:underline;
}


nav .toc-inner a.external-link:not(.button):hover:before {
  content:'open_in_new';
  float:right;
  margin-right:-1em;
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 18px;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-feature-settings: 'liga';
  -webkit-font-smoothing: antialiased;
  opacity:0.5;
}

a.button {
    padding: 0.5em 1.0em;
    background-color: rgb(17, 85, 204);
    color: white;
    text-decoration: none;
    border-radius:100px;;
    display: inline-block;
}
nav .toc-inner p > a.button,
nav .toc-inner a.button {
  padding: 0.5em 1.0em;
  margin: 0;
  width: auto;
  display: inline-block;
}

a.button:hover {
  background-color: rgb(13 65 156);
  color: white;
  text-decoration: none;
}

.material-icon {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-feature-settings: 'liga';
  -webkit-font-smoothing: antialiased;
}

main a,
main u {
  text-decoration:none;
  color:#1a73e8;
}
main a:hover {
  text-decoration-line: underline;
  text-decoration-style: solid;
}

main a.heading-link:hover {
  text-decoration-line: underline;
  text-decoration-style: dotted;
}

.doc-inner {
    padding:72px 2em;
    max-width: 45em;
    margin: auto;
}
.doc-inner.has-hero {
  padding-top:36px;
}

.toc-inner {
  padding:36px 0;
}

main .title { font-size: 2.5em; margin-top:1.5em; margin-bottom:8px;}
main .subtitle { font-size: 12px; margin-bottom:8px; margin-top:-8px;}
main h1 { font-weight: 400; font-size:18px; margin-top:1.5em;}
main h2 { font-weight: 400; font-size:14px; margin-top:1.5em;}
main h3 { font-weight: 400; font-size:14px; margin-top:1.5em;}
main h4 { font-weight: 400; font-size:14px; }
main h5 { font-weight: 400; font-size:14px; }
main h6 { font-weight: 400; font-size:14px; }
main table {
  width:100%;
  border-spacing: 0;
  border-collapse: collapse;
}
main table td {
  border: 1px solid rgba(0,0,0,0.05);
  line-height:100%;
}

main td ul {
  padding-inline-start: 12px;
}

hr { border:none; border-top: 0.5px solid currentColor; opacity:0.2;}

nav .title {font-size: 22px; margin-bottom:20px;}
nav .subtitle {font-size: 14px; opacity: 0.4}
nav h1 { font-weight: 700; font-size:14px; margin:0;}
nav h2 { font-weight: 400; font-style: oblique; font-size:14px; margin:0; color:rgba(0,0,0,0.5)}
nav h3 { font-weight: 400; font-size:14px; margin:0;}
nav h4 { font-weight: 400; font-size:14px; margin:0;}
nav h5 { font-weight: 400; font-size:14px; margin:0;}
nav h6 { font-weight: 400; font-size:14px; margin:0;}
nav hr { margin: 4px -24px -4px -32px; opacity: 0.2;}



nav p {
  margin: 0;
  color:rgba(0,0,0,.33);
}

nav p a {
  color: rgb(97, 97, 97);
}

nav p a:hover {
  color: rgb(0, 0, 0);
}

td {
  vertical-align: top;
}

div.menu-button {
  width:24px; height:24px;
  top:0;
  left:0;
  float:right;
  padding:8px;
  display:inline-block;
  color:rgba(0,0,0,0.4);
  z-index:20;
  border-radius:0px;
  position:relative;
  cursor:default;
}

div.menu-button .material-icons:hover,
div.menu-button.open .material-icons {
  background-color: rgba(0,0,0,0.1);
}

.menu-contents {
  float:right;
  padding: 8px 0;
  margin-top:-2px;
  box-shadow: 0 10px 20px rgb(0 0 0 / 8%), 0 0.5px 1px 0.5px rgb(0 0 0 / 26%);
  border-radius: 4px;
  min-width: 100px;
  background-color:white;
  display:none;
}

.menu-item {
  cursor:default;
  padding: 8px 24px;
  white-space:nowrap;
  color:black;
}

.menu-item:hover {
  background-color:#fafafa
}
.menu-button.open .menu-contents {
  display:block;
}

main p {
  margin-block-start: 0;
  margin-block-end: 0;
  white-space: pre-wrap;
}

#new {
  padding: 2em;
  width: 320px;
  left: 8px;
  position: absolute;
  top: 8px;
  box-shadow: 0 10px 20px rgb(0 0 0 / 8%), 0 0.5px 1px 0.5px rgb(0 0 0 / 26%);
  z-index:100;
  background:white;
  box-sizing:border-box;
  flex-direction:column;
  display:none;
  border-radius:4px;
}
#new input {
    width: 100%;
    font-size: 16px;
    display: block;
    padding: 0.5em 0.5em;
    box-sizing: border-box;
}

#new input[type="submit"],
#new input[type="button"] {
  border:none;
  margin-top:1em;
  width:50%;
  font-size: 16px;
  border-radius:2px;
}


#new input[type="submit" i] {
  background:black;
  color:white;
  margin-left:1em;
}

body.new #new {
  display:flex;


}

.error {
  padding: 1em;
  background-color:#f1f1f1;

}

div.doc-index {
  right:0px;
  position:sticky;
  top:0px;
  background-color:white;
  padding:8px 0 8px 8px;
  max-width:128px;
  transition: max-width 200ms, opacity 200ms, right 200ms;
  overflow:hidden;
  text-overflow:ellipsis;
  border-radius:8px;
  margin-top:4px;
  float:right;
}

div.doc-index:hover {
  right:0px;
  max-width:240px;
}

div.doc-index:hover a{
  opacity:1.0;

}

div.doc-index a.d1 {
  font-weight:bold;
}
div.doc-index a.d2 {

}

div.doc-index a {
  display:block;
  padding: 4px 24px 4px 24px;
  line-height:21px;
  white-space:nowrap;
  text-overflow:ellipsis;
  color: currentColor;
  overflow:hidden;
  opacity:0.5;
}

div.doc-index a:hover {
  background-color:#fafafa;
  text-decoration:none;
}

.doc-index-link {
  border-left:1px solid rgba(0,0,0,0.2);
}

.doc-index-link.selected {
  border-left:1px solid black;
}

.highlighted {
  background-color:#fef7e0;
}

@media only screen and (max-width: 900px) {

  body:not(show-index) .doc-index {
    display:none;
  }

  

  body.show-nav .content {
    transform: translateX(240px);
  }
  body:not(.show-nav) nav {
    transform: translateX(-240px);
  }

  body .content,
  body nav {
    transition:transform 200ms ease;
  }
  
  .content {
    left:0;
    width:100%;
  }

  .doc-inner .img-container.full-width {
    max-width:100%
  }
  .img-container.float-left,
  .img-container.float-right {
    max-width:50%;
  }

  body.loading::before {
      left: auto;
      right: 12px;
      top:12px;
  }

}

.page-footer {
    bottom: 0;
    margin-top:72px;
    display: flex;
    right: ;
    justify-content: space-between;
    margin-bottom:-36px;
}
.page-button {
  text-decoration:none;
  color:currentColor;
  flex-grow:1;
  padding:1em 2em;
  font-size:125%;
}
.page-button:not(:hover) label {
  opacity:0.5;
}
.page-button:hover {
  background:rgba(0,0,0,0.1);
  text-decoration:none;
}

#prev-page {
  margin-left:-2em;
}

#prev-page .material-icon {
  float:left;
  margin-left:-1.1em;
}

#next-page {
  text-align:right;
  margin-right:-1.5em;
}

#next-page .material-icon {
  float:right;
  margin-right:-1.1em;
}

.mobile-header {
  border-radius:22px;
  display: flex;
  position: fixed;
  z-index: 100;
  line-height: 44px;
}

.mobile-header .title {
  flex-grow:1;
}

#nav-toggle {
  padding: 10px 0px 10px 0;
  mix-blend-mode:difference;
  background-color:white;
  border-bottom-right-radius: 10px;
  transition:background-color 1s;
}

body.show-nav #nav-toggle {
  background-color:transparent;
}

</style>
</head>
<body>
<form id="new" onsubmit="submitNewToc(); return false;">
  <input id="new-url" type="text" placeholder="Paste a Google Docs Link">
  <div style="display:flex">
    <input type="button" onclick="document.body.classList.remove('new')" value="Cancel">
    <input type="submit" value="Create">
  </div>
</form>
<header class="mobile-header">
  <div id="nav-toggle" class="material-icons" onclick="toggleNav()">more_vert</div>
</header>
<nav>
  <div id="menu-button" class="menu-button" onclick="this.classList.toggle('open'); event.stopPropagation();">
    <div class="material-icons" onclick="editMode(event)">edit</div>
    <!-- <div class="menu-contents">
      <div class="menu-item action-edit-mode" onclick="editMode(event)">Edit Document</div>
      <div class="menu-item action-new-toc" onclick="createNewToc()">Create New...</div>
    </div> -->
  </div>
  <div id="toc" class="toc-content"></div>
</nav>
<main id="doc" class="content"></main>
<iframe id="doc-frame" class="content" name="frame" src=""></iframe>
</body>

<script>
  window.preloadData = JSON.parse('<?= data ?>');
</script>
<script>
  const URL_REWRITES = [
    { name: "Figma",
      re: /^https:\/\/([^\/\.]+\.)?figma.com\/(?<mode>file|proto)\/(?<id>[0-9a-zA-Z]{22,128})(?:\/.*)?$/,
      sub: "https://www.figma.com/embed?embed_host=astra&url=$&"},
    { name: "YouTube",
      re: /https:\/\/(youtu.be|www.youtube.com)\/(watch\?v=)?(?<id>\w+)([?&](?<params>t=.*)?)?/,
      sub: "https://www.youtube.com/embed/$<id>?autoplay=1&$<params>"},
    { name: "Drive",
      re: /https:\/\/drive.google.com\/file\/d\/(?<id>[\w-]+)(\/.*)?/,
      sub: "https://drive.google.com/file/d/$<id>/preview"},
  ]

const docsRE = /https:\/\/docs.google.com\/(?<type>document|spreadsheets|presentation)\/d\/(?<id>[^\/]*)\/?(?<mode>[^#]*)(#(?<hash>(heading=)?(?<heading>[^=]*).*))?/
  const figmaRE = /^https:\/\/([^\/\.]+\.)?figma.com\/(?<mode>file|proto)\/(?<id>[0-9a-zA-Z]{22,128})(?:\/.*)?$/

  let tocId = window.preloadData.tocId;
  let docId = window.preloadData.docId;
  let tocData = window.preloadData.tocData;
  let docData = window.preloadData.docData;
  let docTitle;
  let tocFavicon;
  let globalMode = window.preloadData.mode;
  let currentHeading = window.preloadData.heading
  let nextPage;
  let prevPage;

  let storage;
  try {
    storage = window.localStorage
  } catch (e) {
    console.log("Can't access localStorage", e)
  }

  if (docData && docData != {} && !docData.error) {
    storage?.setItem(doc.id, JSON.stringify({ts:new Date().getTime(), val:docData}));
  }

  window.top.postMessage({ready:true}, '*')

  google.script.url.getLocation(function(location) {
    hash = location.hash
  });


function loadDocInline(doc, isToc = false, ignoreCache = false) {
  window.scrollTo({ top: 0, behavior: 'smooth' });

  let hasOldData = false;
  if (!ignoreCache) {
    if (docData && doc.id == docData.documentId) {
      console.log("💾 Rendering Doc Data", doc.id)
      renderDocument(doc, docData, false);
      docData = undefined;
      return;
    } 
    
    let cache = storage?.getItem(doc.id)
    if (cache) {
      console.log("💾 Rendering Cache", doc.id)
      let data = JSON.parse(cache);

      if (data.ts) {
        renderDocument(doc, data.val, isToc);
        if (new Date().getTime() - data.ts < 25 * 60 * 1000) {
          return;
        }
        hasOldData = true;
      } 
    }
  }

  console.debug("⬇️ Fetching:", doc.id)
  if (!isToc) document.body.classList.add(hasOldData ? "outofdate" :"loading");
  google.script.run
  .withFailureHandler((e) => console.log("ERROR", e))
  .withSuccessHandler(gotData.bind(null, doc, isToc)).getData(doc.id, ignoreCache);

}

// Parse data
function gotData(doc, isToc, response) {
  let data = JSON.parse(response)
  if (!isToc && doc.id != docId) {
    console.log("ignoring load of old document", doc)
    return;
  }
  renderDocument(doc, data, isToc)
  document.body.classList.remove("loading");
  document.body.classList.remove("outofdate");
  if (!isToc && !data.error) {
    storage?.setItem(doc.id, JSON.stringify({ts:new Date().getTime(), val:data}));
  }
}


// Utility Functions


// Core create-element function
var m = function createElement(type, attrs, ...children) {
  var types = type.split(".")
  var node = document.createElement(types.shift());

  for (var prop in attrs) {
    if (!attrs.hasOwnProperty(prop)) continue;
    if (attrs[prop] != undefined) node[prop] = attrs[prop];
  }

  for (let type of types) node.classList.add(type);
  
  function append(child) {
    if (Array.isArray(child)) return child.forEach(append); 
    if (typeof child == 'string') child = document.createTextNode(child);
    if (child) node.appendChild(child);
  }
  
  children.forEach(append);
  return node;
}




const TYPE_TO_SELECTOR = {
  TITLE: 'div.title',
  SUBTITLE: 'div.subtitle',
  NORMAL_TEXT: 'p'
}

function typeToSelector(type) {
  return TYPE_TO_SELECTOR[type] ||  (type.charAt(0) + type.charAt(type.length-1))
}

function colorForObject(rgb) {
  if (rgb) return `rgb(${(rgb.red || 0) * 255},${(rgb.green || 0)  * 255},${(rgb.blue || 0)  * 255})`;
}

// CSS Creation

function cssForDoc(doc, isToc) {
  let css = []

  let color = colorForObject(doc.documentStyle?.background?.color?.color?.rgbColor)
  if (color) css.push((isToc ? 'nav' : 'main')  + `{background-color:${color}}`);

  if (!isToc) {
    let docStyle = doc.documentStyle;
    css.push(`.doc-inner {--content-width:${docStyle.pageSize.width.magnitude - docStyle.marginLeft.magnitude - docStyle.marginRight.magnitude}pt; max-width:var(--content-width);}`);
  }

  for (let info of doc.namedStyles?.styles) {
    let type = info.namedStyleType;
    let selector = typeToSelector(type);
    
    let declarations = [];
    if (info.textStyle.fontSize) {
      declarations.push(`font-size:${styleForMeasurement(info.textStyle.fontSize)}`);
    }
    if (info.textStyle.weightedFontFamily?.fontFamily) {
      declarations.push(styleForFont(info.textStyle.weightedFontFamily));
      maybeLoadFont(info.textStyle.weightedFontFamily.fontFamily);
    }
    if (info.textStyle.foregroundColor) {
      declarations.push(`color:${colorForObject(info.textStyle.foregroundColor.color.rgbColor)}`);
    }
    if (info.textStyle.bold) {
      declarations.push(`font-weight:bold;`);
    }
    if (declarations.length) {
      css.push(`main ${selector}{${declarations.join(";")}}`);
    }
  }
  return css.join("");
}


// Element Creation 
function styleForMeasurement(m) {
  return (m.magnitude + m.unit)
}

function styleForFont(f) {
  return `font-weight:${f.weight}; font-family:${fontSubstitutes[f.fontFamily] || f.fontFamily}, sans-serif`;
}

function elementForParagraph(p, doc) {
    if (!p) return null;
    let selector = typeToSelector(p.paragraphStyle.namedStyleType); 

    let attrs = {}
    let style = p.paragraphStyle;
    let css = [];

    if (!style.headingId && p.bullet && !doc.isToc) {
      selector = 'li';
      let level = p.bullet.nestingLevel || 0;
      selector += ".bullet-" + level;
    };

    if (style.shading && !doc.isToc) {
      let color = colorForObject(style.shading?.backgroundColor?.color?.rgbColor);
      if (color && color != "rgb(255,255,255)") css.push("background-color:" + color +"; padding: 1em; ");
    }

    if (style.spaceBelow) css.push("margin-block-end:" + styleForMeasurement(style.spaceBelow));
    if (style.spaceAbove) css.push("margin-block-start:" + styleForMeasurement(style.spaceAbove));

    if (style.alignment) css.push("text-align:" + style.alignment);
    if (p.paragraphStyle?.headingId) attrs.id = p.paragraphStyle.headingId;

    if (css.length) attrs.style = css.join(";");

    let paragraph = m(selector, attrs, 
      p.elements?.map(e => elementForElement(e, doc, style.headingId))
    )

    if (p.positionedObjectIds) {
      paragraph = m('div', {}, p.positionedObjectIds?.map(o => elementForObject(doc.positionedObjects[o], doc)), paragraph);
    }
    paragraph.data = p;
    return paragraph;
}

function elementForElement(e, doc, headingId) {
  
  if (e.inlineObjectElement) {
    return elementForObject(doc.inlineObjects[e.inlineObjectElement.inlineObjectId], doc, e.inlineObjectElement);
  }

  if (e.horizontalRule) { return m('hr'); }
  
  let text = e.textRun?.content
  if (!text) {
    return null;
  }
  let el = text;

  el = el.replaceAll('\u000b', '\n')
  
  let css = [];
  let params = {}
  let runStyle = e.textRun?.textStyle
  let buttonMatch = el.match(/^\((?<title>.*)\)$/)
  let frameMatch = el.match(/^\[(?<title>.*)\]$/)
  if (!doc.isToc) {
    if (runStyle.underline) el = m('u',{}, el);
    if (runStyle.italic) el = m('i',{}, el);
    if (runStyle.bold) el = m('b',{}, el);
    if (runStyle.strikethrough) el = m('strike',{}, el);
    if (runStyle.baselineOffset == "SUPERSCRIPT") el = m('sub',{}, el) ;
    if (runStyle.baselineOffset == "SUBSCRIPT") el = m('sup',{}, el) ;

    if (runStyle.backgroundColor) css.push("background-color:" + colorForObject(runStyle.backgroundColor.color.rgbColor))
    if (!headingId && runStyle.foregroundColor && (!buttonMatch || runStyle.backgroundColor) ) {
      css.push("color:" + colorForObject(runStyle.foregroundColor.color.rgbColor))
    }
    
    if (runStyle.weightedFontFamily) {
      css.push(styleForFont(runStyle.weightedFontFamily));
      maybeLoadFont(runStyle.weightedFontFamily.fontFamily);
    }
  } else {
    // el = el.trim();
  }
  
  if (runStyle.link) {
    let url = runStyle.link.url
    if (url) {
      let id = idForUrl(url)
      let selector = "a"
      let external = !urlIsEmbeddable(url);
        
      if (external) selector += ".external-link";
      if (buttonMatch) {
        selector += ".button";
        el = buttonMatch.groups.title
      } 
      el = m(selector, {id, href:url, style: css.join(";")}, el);
    } else {
      el = m('a.heading-link', {href: "#" + runStyle.link.headingId, style: css.join(";") }, el);
    }
  } else {
    if (css.length) {
      el = m('span', {style: css.join(";")}, el);
    }
  }
  return el;
}

let ERROR_DESCRIPTIONS = {
  403: "This document may not be shared with others"
}
function elementForObject(info, doc, element) {
  info = info.positionedObjectProperties || info.inlineObjectProperties;
  if (!info) return;

  let object = info.embeddedObject
  if (!object.imageProperties?.contentUri) return;
  let styles = [];
  let containerStyles = [];

  let containerClass = ['div', 'img-container'];
  let position = info.positioning;
  let w = object.size.width.magnitude;
  let h = object.size.height.magnitude;

    let docStyle = doc.documentStyle;
    let pageWidth = docStyle.pageSize.width.magnitude - docStyle.marginLeft.magnitude - docStyle.marginRight.magnitude;
    if (w - pageWidth > -100) {
      containerClass.push("full-width");
    }

  if (pos = info.positioning) {
    if (pos.layout == "WRAP_TEXT") {
      if (pos.leftOffset.magnitude > (pageWidth / 2))  {
        containerClass.push("float-right");
      } else {
        containerClass.push("float-left");
      }
      
    } else if (pos.layout == "BREAK_LEFT_RIGHT") {
      containerClass.push("block");
    } else {
      if (pos.layout == "IN_FRONT_OF_TEXT") containerStyles.push(`position:absolute; z-index:1;`);
      if (pos.layout == "BEHIND_TEXT") containerStyles.push(`position:absolute; z-index:-1`);
      if (pos.leftOffset) containerStyles.push(`margin-left:${pos.leftOffset?.magnitude}pt;`);
      if (pos.topOffset) containerStyles.push(`margin-top:${pos.topOffset?.magnitude}pt;`);
    }
  } else {
    containerStyles.push(`display:inline-block`);
  }


  // TODO: This is incorrect because offsets should be based on the original image width, which the API does not provide.
  // https://developers.google.com/docs/api/reference/rest/v1/CropProperties

  let crop = object.imageProperties?.cropProperties;
  if (false) {
    let t = 0 - (crop.offsetTop || 0);
    let l = 0 - (crop.offsetLeft || 0);
    let r = 1 + (crop.offsetRight || 0);
    let b = 1 + (crop.offsetBottom || 0);
    styles.push(`background-position:${l * w}pt ${t * h}pt`)  
    styles.push(`background-size:${(r - l) * w}pt ${(b - t) * h}pt`)  
  }

  let ratio = h/w * 100;
  styles.push(`padding-top:${ratio}%`)
  styles.push(`background-image:url(${object.imageProperties?.contentUri})`)  
  containerStyles.push(`width:${w}pt`)

  let img = m(doc.isToc ? 'div.img' : 'div.img.lazy', {style:styles.join(";")});

  let link = element?.textStyle?.link?.url;
  if (link) {
    link = rewriteUrl(link) || link
    containerStyles.push(`height:${h}pt`)
    img =  m('div.iframe-container', {style:styles.join(";")}, m('iframe.embed', {src: link}));
  } 
  
  return m(containerClass.join("."), {style:containerStyles.join(";")}, img )
}

function borderForObject(border) {
  return `${border.width.magnitude}px ${border.dashStyle} ${colorForObject(border.color?.color?.rgbColor)}`
}
function elementForTable(table, doc) {
  // There is a bug in the table API that causes table-level borders to be omitted from the response - see https://stackoverflow.com/questions/59192557/table-border-in-google-docs-api
  let rows = table.tableRows.map(tr => {
    let minHeight = tr.tableRowStyle?.minRowHeight;
    if (minHeight.magnitude < 0.08) return null; // 0.001 min row height is used to hide tables from view mode
    let cells = tr.tableCells.map(td => {
      let style = td.tableCellStyle;
      let attrs = {
        colSpan: style.columnSpan,
        rowSpan: style.rowSpan,
      }

    let css = []
    if (style.backgroundColor?.color) css.push("background-color:" + colorForObject(style.backgroundColor?.color?.rgbColor));
    if (style.paddingLeft) css.push("padding:" + style.paddingLeft.magnitude + "pt");
    if (style.borderTop) css.push(`border-top:${borderForObject(style.borderTop)}`);
    if (style.borderLeft) css.push(`border-left:${borderForObject(style.borderLeft)}`);
    if (style.borderBottom) css.push(`border-bottom:${borderForObject(style.borderBottom)}`);
    if (style.borderRight) css.push(`border-right:${borderForObject(style.borderRight)}`);
    if (style.contentAlignment) css.push(`vertical-align:${style.contentAlignment}`);

    if (css.length) attrs.style = css.join(";")
      return m('td',attrs, elementForBody(td, doc))
    })
    return m('tr', {style:'height:' + styleForMeasurement(minHeight)}, cells);
  })
  return m('table', {}, rows);
}

function expandDocUrl(url) {
  if (!url.startsWith("http")) {
    url = urlForDocInfo({id:url}, true)
  }
  return url;
}

const olMap = {"DECIMAL": "1", "ALPHA": "a", "ROMAN": "i"}

function elementForBody(body, doc) {

  let isRoot = !body.tableCellStyle;
  let heroEl;
  let headingStack = [];
  let bulletStack = [];
  let firstParagraph = false;

  
  let docType = doc.isToc ? 'toc' : 'doc';

  let rootEl = isRoot ? m('div.' + docType + '-inner', {}) : m('div', {})
  let docIndexEl = doc.isToc || !isRoot ? undefined : m('div.doc-index', {})

  for (const c of body.content) {
    let el;
    
    if (c.paragraph) {
      el = elementForParagraph(c.paragraph, doc);
      if (!doc.isToc && !firstParagraph) {
        firstParagraph = true;
        let firstChild = el.children[0];
        if (firstChild && firstChild.classList.contains('img-container') && firstChild.classList.contains('full-width')) {
          heroEl = firstChild;
          heroEl.style.width = '100%';
          heroEl.classList.add('hero')
          el.removeChild(firstChild)
        }
      }
    } else if (c.table) {
      el = elementForTable(c.table, doc);
    }

    let headingId = c.paragraph?.paragraphStyle?.headingId
    let depth = parseInt(c.paragraph?.paragraphStyle?.namedStyleType?.slice(-1));
    if (c.paragraph?.paragraphStyle?.namedStyleType == "TITLE") depth = 0;

    if (headingId) {
      let index = headingStack.findIndex(h => h.depth >= depth );
      if (index != -1) headingStack.splice(index);
    }

    
    let parent = headingStack.length ? headingStack[headingStack.length - 1].el : rootEl;
  
    let bullet = c.paragraph?.bullet;
    if (bullet && !headingId) {
      let list = doc.lists[bullet.listId];
      let nestingLevel = bullet.nestingLevel || 0;
      let listInfo = list.listProperties.nestingLevels[nestingLevel];
      
      let ul;
      let index = bulletStack.findIndex(h => h.nestingLevel >= nestingLevel );
      if (index != -1)  {
        bulletStack.splice(index + 1); 
        index = bulletStack.length - 1;
        let item = bulletStack[index]
        if (item.id != bullet.listId) {
          bulletStack = [];
        } else {
          ul = item.el
        }
      }

      if (!ul) {
        ul = m(listInfo.glyphSymbol ? 'ul' : 'ol', {type: olMap[listInfo.glyphType]});
        (bulletStack.length ? bulletStack[bulletStack.length - 1].el : parent).appendChild(ul);
        bulletStack.push({el: ul, nestingLevel: nestingLevel, id: bullet.listId })     
      }
      parent = ul;
    }

    if (headingId) {
      if (depth >= 0) {
        if (docIndexEl && depth <= 2 && el.innerText.trim().length) {
          docIndexEl.appendChild(m('a.doc-index-link.d' + depth, {href:"#" + headingId, id:"index-" + headingId}, el.innerText))
        }
        el.classList.add("heading")
        if (depth > 0) {

          let headingChildren = m('div.heading-children', {depth:depth, id:headingId + "-children"});   
          let containerClasses = ['div', 'heading-container'];
          if (bullet) {
            containerClasses.push('collapsable')
            containerClasses.push('collapsed')
          }
          containerClasses.push("heading-" +depth);
          el = m(containerClasses.join('.'), {id: headingId + "-container"}, el, headingChildren)
          headingStack.push({depth: depth, el: headingChildren})
        }
      }
    }

    if (el) parent.appendChild(el)
  }

  if (heroEl) {
    rootEl.classList.add('has-hero')
  }

  if (!doc.isToc && isRoot && (nextPage || prevPage)) {
    let footer = m('div.page-footer', {}, 
      prevPage ? m('a.page-button', {id: "prev-page", href: prevPage?.href}, m('label',{}, "Previous"), m('br'), m('div.material-icon',{},"chevron_left"), prevPage?.innerText) : null,
      nextPage ? m('a.page-button', {id: "next-page", href: nextPage?.href}, m('label',{}, "Next"), m('br'), m('div.material-icon',{},"chevron_right"), nextPage?.innerText) : null
    )
    rootEl.appendChild(footer);
  }

  return [heroEl, docIndexEl, rootEl];
}

function lazyLoadImages(images, i = 0) {
  images[i]?.classList.remove("lazy");
  if (i + 1 < images.length) {
    setTimeout(lazyLoadImages.bind(null, images, i+1), 10)
  }
}

function renderDocument(docInfo, doc, isToc) {
  
  // Create elements for document content
  if (isToc) doc.isToc = true;

  let docType = doc.isToc ? 'toc' : 'doc';
  console.log("📐 Rendering", docType, [doc.documentId, doc])

  let rootEl = m('div.' + docType + '-inner', {})

  let docEl = document.getElementById(docType);
  while (docEl.firstChild) docEl.removeChild(docEl.lastChild);

  if (doc.error) {
    console.log("Error:", doc.error)
    rootEl.appendChild(m("div.error", {},
      m('b', {}, ERROR_DESCRIPTIONS[doc.error.details?.code]),
      m('br'),
      m('p', {}, doc.error.details.message),
      m('i', {}, doc.error.name, " ",  doc.error.details?.code.toString())
      ));
  } else {
    let contentEls = elementForBody(doc.body, doc, true);
    contentEls.forEach(el => { if (el) docEl.appendChild(el)})
  }

  // Create CSS rules for document styles
  let css = cssForDoc(doc, isToc) // isToc ? cssForDoc(doc) : undefined;
  if (css && css.length) {
      docEl.appendChild(m('style', {type:'text/css'}, css))
  }

  let images = docEl.querySelectorAll(".img.lazy");
  lazyLoadImages(images)
 
  
  if (isToc) {
    let url;
    document.title = doc.title;
    //document.getElementById('page-title').innerText = doc.title;

    if (doc.inlineObjects) {
      let obj = Object.values(doc.inlineObjects).pop();
      let favicon = obj.inlineObjectProperties?.embeddedObject?.imageProperties?.contentUri + "?.png";
      window.top.postMessage({favicon}, '*')
    }
  
    if (docId && docId.length) {
      url = expandDocUrl(docId)
    } else {
      let links = docEl.querySelectorAll("a[href]");
      for (let link of links) {
        if (urlIsEmbeddable(link.href)) {
          link.classList.add('selected');
          url = link.href
          break;
        }
      }
    
    }
    
    if (url) displayDoc(url);
  } else if (docInfo.heading || currentHeading) {
    scrollToHeader(docInfo.heading || currentHeading, true)
  } else {
    google.script.url.getLocation(function(location) {
      hash = location.hash
      if (hash.length) {
        console.log("Scrolling to", hash)
        scrollToHeader(hash)
      }
    });
  }
}

function scrollToHeader(hash, updateHistory = false) {
    currentHeading = hash;
  if (!hash || !hash.length) return;
  let el = document.getElementById(hash);
  if (el) {
      if (updateHistory) updateHistoryState()
    el.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start'});
    el.classList.add('highlighted');
    setTimeout(() => el.classList.remove('highlighted'), 1000)
  }
  //TODO: https://stackoverflow.com/questions/48634459/scrollintoview-block-vs-inline/48635751#48635751
}

function docInfoForUrl(url) {
  let match = url.match(docsRE)
  return match?.groups;
}

function idForUrl(url) {
  if (url) {
    let info = docInfoForUrl(url);
    if (info && info.type == 'document' && info.mode != 'preview') return info.id;
  }
  return url;
}

function urlForDocInfo(doc) {
  let url = "https://docs.google.com/" + (doc.type || 'document') + "/d/";
  url += doc.id + "/" + (doc.mode || 'edit');
  if (doc.hash) url += "#" + doc.hash;
  return url;
  //return `https://docs.google.com/document/d/${doc.id}/${doc.mode}` //|| ''}` + ${doc.header ? '#header=' + header : ''}
}

function createNewToc() {
  document.body.classList.add("new");
  document.getElementById("new-url").focus()
}

function submitNewToc() {
  let link = document.getElementById("new-url").value
  let docInfo = link.startsWith("http") ? docInfoForUrl(link) : {id:link};
  if (docInfo.id) {
    tocId = docInfo.id;
    docId = '';
    docData = {};
    tocData = {};
    // google.script.run.withSuccessHandler(url => {
    //   window.open(url + "?toc=" + docInfo.id, "_top");
    // }).getUrl();
    updateHistoryState(true);

    loadDocInline({id: tocId}, true, true)
  }


  document.body.classList.remove("new");
}

document.addEventListener('scroll', (e) => {
  var scrollHeading = undefined
  let headings = document.querySelectorAll(".doc-inner .heading");
  let indexes = document.querySelectorAll(".doc-index-link");
  for (let heading of Array.from(headings).reverse()) {
      if (heading.offsetTop < window.pageYOffset + 24) {
      scrollHeading = heading.id;
      break;
    }
  }
  
  
  if (currentHeading != scrollHeading) {
      currentHeading = scrollHeading
    updateHistoryState(true);
    let index = document.getElementById("index-" + currentHeading);
    indexes.forEach(i => i.classList.remove("selected"))
    if (index) index.classList.add("selected")
  }
})


document.addEventListener('touchstart', handleTouchStart, false);        
document.addEventListener('touchmove', handleTouchMove, false);

var xDown = null;                                                        
var yDown = null;
                                                       
function handleTouchStart(evt) {
    const firstTouch = evt.touches;                                      
    xDown = firstTouch.clientX;                                      
    yDown = firstTouch.clientY;                                      
};                                                
                                                                         
function handleTouchMove(evt) {
    if ( ! xDown || ! yDown ) {
        return;
    }

    var xUp = evt.touches[0].clientX;                                    
    var yUp = evt.touches[0].clientY;

    var xDiff = xDown - xUp;
    var yDiff = yDown - yUp;
                                                                         
    if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) {/*most significant*/
        if ( xDiff > 0 ) {
            /* right swipe */ 
            toggleNav(true);
        } else {
            /* left swipe */
        }                       
    } else {
        if ( yDiff > 0 ) {
            /* down swipe */ 
        } else { 
            /* up swipe */
                        toggleNav(false);

        }                                                                 
    }
    /* reset values */
    xDown = null;
    yDown = null;                                             
};


document.addEventListener('click', function(e) {
  document.getElementById('menu-button').classList.remove('open');

  if (e.target.closest('main')) {
    toggleNav(false);
  }
  let a = e.target.closest('a');
  if (a) {
    e.preventDefault();
    let url = a.getAttribute('href');
    if (url == "https://gdoc.app/new") { return createNewToc(); }
    if (url) {
      toggleNav(false);
      let ignoreCache = docId == docInfoForUrl(url)?.id;  

      displayDoc(url, e.altKey, true, ignoreCache || e.shiftKey, a)
    }
    return false;
  } else {
    if (e.target.classList.contains('title') && e.target.closest('nav') ) {
      if (e.shiftKey) {
        reloadToc();
      } else if (e.altKey || globalMode == 'edit') {
        editToc(e);
      }
    } else if (e.target.id) {
      let container = document.getElementById(e.target.id + "-container")
      if (container && container.classList.contains('collapsable')) container.classList.toggle('collapsed')
    }

  }
})

window.addEventListener("message", e => {
  let path = e.data.path;
  console.log("Got Message", path)
    if (path) {
    let components = path.split("/");
    if (components.length > 1) data.tocId = components[1]
    if (components.length > 2) data.docId = components[2]
    if (components.length > 3) data.heading = components[3]
  }
  
}, false);

function editToc(e) {
  let url = "https://docs.google.com/document/d/" + tocId + "/edit";
  if (e.metaKey || e.ctrlKey) {
    window.open(url, '_blank');
  } else {
    displayDoc(url, true)
  }
}

function reloadToc() {
  tocData = undefined
  loadDocInline({id: tocId}, true, true)
}

function toggleNav(value) {
  document.body.classList.toggle('show-nav', value)
}

function toggleIndex() {
  document.body.classList.toggle('show-index', value)
}

function isMobile() {
  return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
}

function editMode(e) {
  let url = docId;
  if (!url.startsWith("http")) url = urlForDocInfo({id:docId})

  if (isMobile) {
    return window.open(url, '_blank');
  }
  
  if (globalMode != 'edit') {
    globalMode = 'edit'
  } else {
    globalMode = 'view'
  }
  document.body.classList.toggle('edit', globalMode == 'edit')
  displayDoc(url)
}
function editDoc(e) {
  let url = docId;
  if (!url.startsWith("http")) url = urlForDocInfo({id:docId}, true)

  if (e.metaKey || e.ctrlKey) {
    window.open(url, '_blank');
  } else {
    displayDoc(url, true)
  }
}

function fullscreen() {
  let el = document.getElementById('doc-frame');
  el.requestFullscreen();
}

function updateTocSelection(url, clickedLink) {
  let id = idForUrl(url); 
  if (docId != id) {
    currentHeading = undefined;
    docId = id;
  }

  if (!clickedLink?.closest('nav')) clickedLink = undefined;
  let links = document.querySelectorAll("nav a")

  if (!clickedLink) {
    links.forEach(link => { 
      if (!clickedLink && (link.id == id)) { clickedLink = link; }
    })
  }
  
  links.forEach((link, i) => {
    link.classList.toggle('selected', link == clickedLink)
    if (link == clickedLink) {
      docTitle = link.innerText
      while (link = link.parentNode.closest('.heading-container')) {
        link.classList.remove('collapsed');
      }
      prevPage = links[i-1];
      nextPage = links[i+1];
      clickedLink = link;
    }
  });
}

function urlIsEmbeddable(url) {
  if (url.indexOf('docs.google.com') > 0) return true;
  for (let rewrite of URL_REWRITES) {
    if (url.match(rewrite.re)) return true;
  }
  return false;
}

function displayDoc(url, editMode = false, updateHistory = true, ignoreCache = false, clickedLink) {
  console.debug("🖼 Displaying", url, ignoreCache)

  if (url.startsWith("#")) return scrollToHeader(url.slice(1), true)

  let target = 'frame';
  let googleDoc = docInfoForUrl(url);  


  if (googleDoc) {
    if (globalMode == 'edit' || url.endsWith("#edit")) editMode = true;
    if (editMode) {
      googleDoc.mode = 'edit';
    } else if (googleDoc.type == "document" && googleDoc.mode != "preview") {
      target = 'inline';
    } else {
      googleDoc.mode = 'preview';
    }
    url = urlForDocInfo(googleDoc)
  } else {
    let rewrite = rewriteUrl(url);
    if (rewrite) {
      url = rewrite;
    } else {
      target = 'blank';
    }
  }

  if (target == 'blank') {
      console.debug("🌐 Opening Tab:", url)
      window.open(url, '_blank');
  } else {
    updateTocSelection(url, clickedLink);

    let frame = document.getElementById('doc-frame');
    if (target == 'inline') {
      loadDocInline(googleDoc, false, ignoreCache);
      document.body.classList.remove('frame');
      frame.src = 'about:blank';
    } else if (target == 'frame') {
      console.debug("🌐 Framing:", url)
      frame.src = url;
      document.body.classList.add('frame');
    }
    
    if (updateHistory) {
      updateHistoryState()
    }
  }
}

function nameToPathComponent(name) {
  return name.trim()
  .toLowercase()
  .replaceAll(" ", "_")
  .replaceAll("&", "and")
  .replace(/[^\-_A-Za-z0-9]/g, '')
}

function updateHistoryState(replace = false) {
  let path = ["", tocId]
  let attrs = {toc:tocId};
  if (docId && docId.length) { 
    path.push(encodeURIComponent(docId)) 
    attrs.doc = docId;
    if (currentHeading && currentHeading.length) {
      path.push(currentHeading)
      attrs.heading = currentHeading
    }
  }
  
  path = path.join("/")

  
  let title = tocData?.title || "Docs"

  if (docTitle) title = docTitle + " - " + title

  //path = nameToPathComponent(title) + "-" + path


  // let favicon = tocFavicon;
  let historyFn = replace ? google.script.history.replace : google.script.history.push;
  historyFn({'timestamp': new Date().getTime(), doc:docId, heading:currentHeading}, attrs);
  window.top.postMessage({path, title}, '*')
}

function rewriteUrl(url) {
  for (let rewrite of URL_REWRITES) {
    let match =  url.match(rewrite.re)
    if (match) {
      return url.replace(rewrite.re, rewrite.sub)
    }
  }
}

let fontSubstitutes = {
  "Consolas": "IBM Plex Mono"
}

let loadedFonts = {}  
var maybeLoadFont = function(font, weight = 400) {
  if (!font) return false;
  font = fontSubstitutes[font] || font;
  if (document.fonts.check("12px " + font )) return false; // No need to load font.
  
  if (loadedFonts[font] == 'loaded') return false;  // Font already loaded.
  if (loadedFonts[font] == 'loading') return true;  // Font is loading, just pretend we're loading it.
  

  loadedFonts[font] = 'loading';
  WebFont.load({
      google: { families: [font + ":400,500,700"] },
      timeout: 2000,
      fontactive: function(family, fvd) {
        console.log('💼 Loaded ' + family);
        loadedFonts[family] = 'loaded';
      },
      fontinactive: function(family, fvd) {
        // Error loading font. Fallback
        loadedFonts[family] = 'loaded';
        console.log('⛔️ Failed to load ' + family);
      }
  });
  return true;
}

google.script.history.setChangeHandler(function (e) {
  let state = e.state;
  console.debug("🕘State Changed", state.doc, [e.state, e.parameter, e.location.hash]);
  displayDoc(expandDocUrl(state.doc))
});

if (!tocId.length) {
  loadDocInline({id: tocId}, true)
} else {
  renderDocument({id: tocId}, tocData, true)
}

</script>
</html>
