<!DOCTYPE html>
<html>
<head>
<title></title>
<base target="_self">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js" doNotEncode></script>
<style>

  body {
    margin:0;
    font-family: "Roboto", system-ui;
    background-color: white;
    font-size: 14px;
    --padding-left: 32px;
    --sidebar-width: 240px;
  }
  
  body.outofdate #doc {
    opacity:0.89;
  }
  
  
  body.loading #doc {
    opacity:0.0;
    transition:opacity 2s cubic-bezier(0,1,0,1);
  }
  
  body.loading::before {
    content:'';
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 10px;
      position: absolute;
      left: calc(50vw + var(--sidebar-width) / 2);
      top: 32px;
      margin-left:-12px;
      z-index:100;
      border-top: 2px solid rgba(0,0,0, 0.0);
      border-right: 2px solid rgba(0,0,0, 0.0);
      border-bottom: 2px solid rgba(0,0,0, 0.0);
      border-left: 2px solid #000000;
      -webkit-transform: translateZ(0);
      -ms-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-animation: load8 1.1s infinite linear;
      animation: load8 1.1s infinite linear;
  }
  
  
  
  @keyframes load8 {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
  }
  
  nav {
    width:var(--sidebar-width);
    height:100vh;
    overflow-y:scroll;
    overflow-x:hidden;
    background:#fefefe;
    box-sizing:border-box;
    border-right:1px solid rgba(0,0,0,0.05);
    position:fixed;
    z-index:10;
    flex-basis:240px;
    flex:0 0 auto;
    user-select:none;
    box-sizing:border-box;
   background-clip: border-box;
  }
  
  main {
    min-height:100vh;
  }
  
  
  
  
  .heading-container.collapsed,
  .heading:before
   {
    cursor:pointer;
  }
  
  nav .heading {
    line-height:24px;
    margin-top:8px;
  }
  
  nav .heading-container.heading-3 >.heading-children,
  nav .heading-container.heading-4 >.heading-children,
  nav .heading-container.heading-5 >.heading-children,
  nav .heading-container.heading-6 >.heading-children {
    margin-left:18px;
  }
  .heading:before {
    content:'chevron_right';
    float:left;
    margin-left:-1em;
    opacity:0.0;
    transition:transform 200ms;
    transform: rotate(90deg);
    font-family: 'Material Icons';
    font-weight: normal;
    font-style: normal;
    font-size: 24px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: 'liga';
    -webkit-font-smoothing: antialiased;
  }
  
  .heading-container.collapsed .heading:before {
     transform: rotate(0deg);
     opacity:1.0;
  }
  
  .heading:hover:before {
    opacity:0.4
  
  }
  
  .heading-container.collapsed .heading-children{
    max-height:0px;
    overflow:hidden;
  }
  
  img {
    max-width:100%;
  }
  
  nav img {
    max-width:100%;
  }
  
  main img {
    margin:0.5em 1em 1em 1em;
  }
  
  .img {
    background-repeat: no-repeat;
    background-size:cover;
  }
  
  .img.hero {
    margin-top:-10em;
    position:absolute;
    width:100%;
  }
  
  .doc-inner .img-container {
    max-width:100%;
    min-width:10px;
    display:inline-block;
    
  }
  
  .img-container.hero {
    max-height: 50vh;
    overflow: hidden;
  }
  
  .doc-inner > p:first-child {
    background-color:red;
    margin:0;
  }
  
  .img-container.float-left {
    float:left;
    margin: 1em 1em 1em 0;
  }
  
  .img-container.float-right {
    float:right;
    margin: 1em 0em 1em 1em;
  }
  
  .img-container.float-right {
    display:block;
    margin: 0em 1em 0em 1em;
  }
  
  .header {
    height:104px;
  }
  
  p, li {
    line-height:150%;
    max-width: 42em;
  }
  
  li {
    margin-bottom:12px;
  }
  
  .li {
    margin-block-start:0.5em;;
    margin-block-end:0.5em;;
  }
  
  .li:before {
    content:'•';
    display:inline-block;
    float:left;
    margin-left:-1.5em;
    opacity:0.75;
  }
  
  .bullet-0 {
    padding-left:2em;
  }
  .bullet-1 {
    padding-left:4em;
  }
  .bullet-2 {
    padding-left:6em;
  }
  
  li::marker {
    margin-left: 1em;
  }
  iframe#doc-frame {
    border:none;
    background-color:#fafafa;
    height:100vh;
  }
  .children {
    /* border:2px solid red; */
    /* padding:2px; */
  }
  .children.collapsed {
    max-height:0;
    overflow:hidden;
  }
  
  .children .children {
      border-color: green;
  }
  
  .children .children {
      border-color: blue;
  }
  
  body.frame #doc,
  body:not(.frame) iframe#doc-frame {
    display:none;
  }
  
  .content {
    position:absolute;
    left:var(--sidebar-width);
    top:0;
    width:calc(100vw - var(--sidebar-width));
    
  }
  
  nav .toc-inner p,
  nav .toc-inner .title,
  nav .toc-inner .subtitle,
  nav .toc-inner .heading,
  nav .toc-inner a {
    display:block;
    text-decoration:none;
    padding: 4px 24px 4px var(--padding-left);
    cursor:default;
  }
  
  
  
  nav .toc-inner .heading a,
  nav .toc-inner p > a {
    margin: -4px -24px -4px -32px;
  }
  
  nav a {
    overflow:hidden;
    white-space:nowrap;
    text-overflow:ellipsis;
  }
  nav a:hover {
    background-color:rgba(0,0,0,0.03);
  }
  
  nav a.selected,
  nav a.selected:hover {
    background-color:rgba(0,0,0,0.1);
  }
  
  
  nav .toc-inner a.external-link,
  a.external-link {
    cursor:alias;
  }
  
  nav .toc-inner a.external-link:hover:before {
    content:'open_in_new';
    float:right;
    margin-right:-1em;
    font-family: 'Material Icons';
    font-weight: normal;
    font-style: normal;
    font-size: 18px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: 'liga';
    -webkit-font-smoothing: antialiased;
    opacity:0.5;
  }
  
  main a,
  main u {
    text-decoration:none;
  }
  main a:hover {
    text-decoration-line: underline;
    text-decoration-style: solid;
  }
  
  main a.heading-link:hover {
    text-decoration-line: underline;
    text-decoration-style: dotted;
  }
  
  .doc-inner {
      padding:72px 2em;
      max-width: 45em;
      margin: auto;
  }
  .doc-inner.has-hero {
    padding-top:36px;
  }
  
  .toc-inner {
    padding:36px 0;
  }
  
  main .title { font-size: 2.5em; margin-top:1.5em; margin-bottom:8px;}
  main .subtitle { font-size: 12px; margin-bottom:8px; margin-top:-8px;}
  main h1 { font-weight: 400; font-size:18px; margin-top:1.5em;}
  main h2 { font-weight: 400; font-size:14px; margin-top:1.5em;}
  main h3 { font-weight: 400; font-size:14px; margin-top:1.5em;}
  main h4 { font-weight: 400; font-size:14px; }
  main h5 { font-weight: 400; font-size:14px; }
  main h6 { font-weight: 400; font-size:14px; }
  main table {
    width:100%;
  }
  
  hr { border:none; border-top: 0.5px solid currentColor; }
  
  nav .title {font-size: 22px; margin-bottom:20px;}
  nav .subtitle {font-size: 14px; opacity: 0.4}
  nav h1 { font-weight: 700; font-size:14px; margin:0;}
  nav h2 { font-weight: 400; font-style: oblique; font-size:14px; margin:0; opacity:0.4}
  nav h3 { font-weight: 400; font-size:14px; margin:0;}
  nav h4 { font-weight: 400; font-size:14px; margin:0;}
  nav h5 { font-weight: 400; font-size:14px; margin:0;}
  nav h6 { font-weight: 400; font-size:14px; margin:0;}
  nav hr { margin: 4px -24px -4px -32px; opacity: 0.2;}
  
  
  
  nav p {
    margin: 0;
    color:rgba(0,0,0,.54);
  }
  
  nav p a {
    color: rgb(97, 97, 97);
  }
  
  nav p a:hover {
    color: rgb(0, 0, 0);
  }
  
  td {
    vertical-align: top;
  }
  
  div.menu-button {
    width:24px; height:24px;
    top:0;
    left:0;
    float:right;
    padding:8px;
    display:inline-block;
    color:rgba(0,0,0,0.4);
    z-index:20;
    border-radius:0px;
    position:relative;
    cursor:default;
  }
  
  div.menu-button .material-icons:hover,
  div.menu-button.open .material-icons {
    background-color: rgba(0,0,0,0.1);
  }
  
  .menu-contents {
    float:right;
    padding: 8px 0;
    margin-top:-2px;
    box-shadow: 0 10px 20px rgb(0 0 0 / 8%), 0 0.5px 1px 0.5px rgb(0 0 0 / 26%);
    border-radius: 4px;
    min-width: 100px;
    background-color:white;
    display:none;
  }
  
  .menu-item {
    cursor:default;
    padding: 8px 24px;
    white-space:nowrap;
    color:black;
  }
  
  .menu-item:hover {
    background-color:#fafafa
  }
  .menu-button.open .menu-contents {
    display:block;
  }
  
  
  #new {
    padding: 2em;
    width: 320px;
    left: 8px;
    position: absolute;
    top: 8px;
    box-shadow: 0 10px 20px rgb(0 0 0 / 8%), 0 0.5px 1px 0.5px rgb(0 0 0 / 26%);
    z-index:100;
    background:white;
    box-sizing:border-box;
    flex-direction:column;
    display:none;
    border-radius:4px;
  }
  #new input {
      width: 100%;
      font-size: 13px;
      display: block;
      padding: 0.5em 0.5em;
      box-sizing: border-box;
  }
  
  #new input[type="submit"],
  #new input[type="button"] {
    border:none;
    margin-top:1em;
    width:50%;
    font-size: 16px;
    border-radius:2px;
  }
  
  
  #new input[type="submit" i] {
    background:black;
    color:white;
    margin-left:1em;
  }
  
  body.new #new {
    display:flex;
  
  
  }
  
  .error {
    padding: 1em;
    background-color:#f1f1f1;
  
  }
  
  div.doc-toc {
    right:0;
    position:fixed;
    width:240px;
    background-color:white;
    padding:12px;
    left: 240px;
    width:24px;
    transition: width 0.2s;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  
  div.doc-toc:hover {
    right:0px;
    width:240px;
  }
  
  div.doc-toc a {
    display:block;
    padding: 0 20px;
    white-space:nowrap;
      text-overflow:ellipsis;
  
  }
  
  @media only screen and (max-width: 900px) {
  nav {
    display:none;
  }
  main.content {
    left:0;
    width:100vw;
  }
  
  }
  </style>
  
</head>
<body>
<form id="new" onsubmit="submitNewToc(); return false;">
  <input id="new-url" type="text" placeholder="Paste a Google Docs Link">
  <div style="display:flex">
    <input type="button" onclick="document.body.classList.remove('new')" value="Cancel">
    <input type="submit" value="Create">
  </div>
</form>
<nav>
  <div id="menu-button" class="menu-button" onclick="this.classList.toggle('open'); event.stopPropagation();">
    <div class="material-icons">more_horiz</div>
    <div class="menu-contents">
      <div class="menu-item action-edit-doc" onclick="editDoc(event)">Edit Document</div>
      <div class="menu-item action-edit-toc" onclick="editToc(event)">Edit Index</div>
      <!-- <div class="menu-item action-fullscreen" onclick="fullscreen()">Fullscreen</div> -->
      <div class="menu-item action-new-toc" onclick="createNewToc()">Create New...</div>
    </div>
  </div>
  <div id="toc" class="toc-content"></div>
</nav>
<main id="doc" class="content"></main>
<iframe id="doc-frame" class="content" name="frame" src=""></iframe>
</body>

<script>

  const URL_REWRITES = [
    { name: "Figma",
      re: /^https:\/\/([^\/\.]+\.)?figma.com\/(?<mode>file|proto)\/(?<id>[0-9a-zA-Z]{22,128})(?:\/.*)?$/,
      sub: "https://www.figma.com/embed?embed_host=astra&url=$&"},
    { name: "YouTube",
      re: /https:\/\/(youtu.be|www.youtube.com)\/(watch\?v=)?(?<id>\w+)([?&](?<params>t=.*)?)?/,
      sub: "https://www.youtube.com/embed/$<id>?autoplay=1&$<params>"}
  ]

  const docsRE = /https:\/\/docs.google.com\/(?<type>document|spreadsheets|presentation)\/d\/(?<id>[^\/]*)\/?(?<mode>[^\n#]*)(#(?<hash>.*))?/
  const figmaRE = /^https:\/\/([^\/\.]+\.)?figma.com\/(?<mode>file|proto)\/(?<id>[0-9a-zA-Z]{22,128})(?:\/.*)?$/

  let tocId = '<?= tocId ?>'
  let docId = '<?= docId ?>';
  let globalMode = <?= mode ?>;
  let hash;

  let tocData = <?!=JSON.stringify(tocData)?>;
  let docData = <?!=JSON.stringify(docData)?>;


  let storage;
  try {
    storage = window.localStorage
  } catch (e) {
    console.log("Can't access localStorage", e)
  }

  if (docData && docData != {} && !docData.error) {
    storage?.setItem(doc.id, JSON.stringify({ts:new Date().getTime(), val:docData}));
  }

  google.script.url.getLocation(function(location) {
    hash = location.hash
  });


function loadDocInline(doc, isToc = false, ignoreCache = false) {
  window.scrollTo({ top: 0, behavior: 'smooth' });

  let hasOldData = false;
  if (!ignoreCache) {
    if (docData && doc.id == docData.documentId) {
      console.log("💾 Rendering Doc Data", doc.id)
      renderContent(docData);
      docData = undefined;
      return;
    } 
    
    let cache = storage?.getItem(doc.id)
    if (cache) {
      console.log("💾 Rendering Cache", doc.id)
      let data = JSON.parse(cache);

      if (data.ts) {
        renderContent(data.val, isToc);
        if (new Date().getTime() - data.ts < 25 * 60 * 1000) {
          return;
        }
        hasOldData = true;
      } 
    }
  }

  console.debug("⬇️ Fetching:", doc.id)
  document.body.classList.add(hasOldData ? "outofdate" :"loading");
  google.script.run
  .withFailureHandler((e) => console.log("ERROR", e))
  .withSuccessHandler(gotData.bind(null, doc, isToc)).getData(doc.id, ignoreCache);

}

// Parse data
function gotData(doc, isToc, response) {
  let data = JSON.parse(response)
  if (doc.id != docId) {
    console.log("ignoring load of old document", doc)
    return;
  }
  renderContent(data, isToc)
  document.body.classList.remove("loading");
  document.body.classList.remove("outofdate");
  if (!isToc && !data.error) {
    storage?.setItem(doc.id, JSON.stringify({ts:new Date().getTime(), val:data}));
  }
}


// Utility Functions


// Core create-element function
var m = function createElement(type, attrs, ...children) {
  var types = type.split(".")
  var node = document.createElement(types.shift());

  for (var prop in attrs) {
    if (!attrs.hasOwnProperty(prop)) continue;
    if (attrs[prop] != undefined) node[prop] = attrs[prop];
  }

  for (let type of types) node.classList.add(type);
  
  function append(child) {
    if (Array.isArray(child)) return child.forEach(append); 
    if (typeof child == 'string') child = document.createTextNode(child);
    if (child) node.appendChild(child);
  }
  
  children.forEach(append);
  return node;
}




const TYPE_TO_SELECTOR = {
  TITLE: 'div.title',
  SUBTITLE: 'div.subtitle',
  NORMAL_TEXT: 'p'
}

function typeToSelector(type) {
  return TYPE_TO_SELECTOR[type] ||  (type.charAt(0) + type.charAt(type.length-1))
}

function colorForObject(rgb) {
  if (rgb) return `rgb(${rgb.red * 255},${rgb.green * 255},${rgb.blue * 255})`;
}

// CSS Creation

function cssForDoc(doc, isToc) {
  let css = []

  let color = colorForObject(doc.documentStyle?.background?.color?.color?.rgbColor)
  if (color) css.push((isToc ? 'nav' : 'main')  + `{background-color:${color}}`);

  if (!isToc) {
    let docStyle = doc.documentStyle;
    css.push(`.doc-inner {max-width:${docStyle.pageSize.width.magnitude - docStyle.marginLeft.magnitude - docStyle.marginRight.magnitude}pt;}`);
  }

  for (let info of doc.namedStyles?.styles) {
    let type = info.namedStyleType;
    let selector = typeToSelector(type);
    
    let declarations = [];
    if (info.textStyle.fontSize) {
      declarations.push(`font-size:${info.textStyle.fontSize.magnitude}${info.textStyle.fontSize.unit};`);
    }
    if (info.textStyle.weightedFontFamily?.fontFamily) {
      declarations.push(`font-family:${info.textStyle.weightedFontFamily.fontFamily}, system-ui, sans-serif;`);
      maybeLoadFont(info.textStyle.weightedFontFamily.fontFamily);
    }
    if (info.textStyle.weightedFontFamily?.weight) {
      declarations.push(`font-weight:${info.textStyle.weightedFontFamily.weight};`);
    }
    if (info.textStyle.foregroundColor) {
      declarations.push(`color:${colorForObject(info.textStyle.foregroundColor.color.rgbColor)};`);
    }
    if (info.textStyle.bold) {
      declarations.push(`font-weight:bold;`);
    }
    if (declarations.length) {
      css.push(`main ${selector}{${declarations.join("")}}`);
    }
  }
  return css.join("");
}


// Element Creation 

function elementForParagraph(p, doc) {
    if (!p) return null;
    let selector = typeToSelector(p.paragraphStyle.namedStyleType); 

    let attrs = {}
    let style = p.paragraphStyle;

    if (!style.headingId && p.bullet && !doc.isToc) {
      selector = 'p.li';
      let level = p.bullet.nestingLevel || 0;
      selector += ".bullet-" + level;
    };
    if (p.table) console.log("p.table", p.table)


    if (style.shading && !doc.isToc) {
      let color = colorForObject(style.shading?.backgroundColor?.color?.rgbColor);
      if (color && color != "rgb(255,255,255)") attrs.style = "background-color:" + color +"; padding: 1em; ";
    }

    if (p.paragraphStyle?.headingId) attrs.id = p.paragraphStyle.headingId;

    return m(selector, attrs, 
      p.positionedObjectIds?.map(o => elementForObject(doc.positionedObjects[o], doc)),
      p.elements?.map(e => elementForElement(e, doc))
    )
}

function elementForElement(e, doc) {
  if (e.inlineObjectElement) {
    return elementForObject(doc.inlineObjects[e.inlineObjectElement.inlineObjectId], doc);
  }
  if (e.horizontalRule) {
    return m('hr');
  }
  
  let text = e.textRun?.content
  if (!text) {
    return null;
  }
  let el = text;
  let params = {}
  let runStyle = e.textRun?.textStyle
  if (!doc.isToc) {
    if (runStyle.underline) el = m('u',{}, el);
    if (runStyle.italic) el = m('i',{}, el);
    if (runStyle.bold) el = m('b',{}, el);
    if (runStyle.strikethrough) el = m('strike',{}, el);
    if (runStyle.baselineOffset == "SUPERSCRIPT") el = m('sub',{}, el) ;
    if (runStyle.baselineOffset == "SUBSCRIPT") el = m('sup',{}, el) ;
    if (runStyle.foregroundColor) el = m('span', {style:"color:" + colorForObject(runStyle.foregroundColor.color.rgbColor)}, el);
  } else {
    // el = el.trim();
  }
  
  if (runStyle.link) {
    let url = runStyle.link.url
    if (url) {
      let id = idForUrl(url)
      let external = !urlIsEmbeddable(url);
      el = m('a' + (external ? ".external-link" : ".embedded-link"), {id, href:url }, el);
    } else {
      el = m('a.heading-link', {href: "#" + runStyle.link.headingId }, el);
    }
  }
  return el;
}

let ERROR_DESCRIPTIONS = {
  403: "This document may not be shared with others"
}
function elementForObject(info, doc) {
  info = info.positionedObjectProperties || info.inlineObjectProperties;
  if (!info) return;

  let object = info.embeddedObject
  if (!object.imageProperties?.contentUri) return;
  let styles = [];
  let containerStyles = [];

  let containerClass = ['div', 'img-container'];
  let position = info.positioning;
  let w = object.size.width.magnitude;
  let h = object.size.height.magnitude;

    let docStyle = doc.documentStyle;
    let pageWidth = docStyle.pageSize.width.magnitude - docStyle.marginLeft.magnitude - docStyle.marginRight.magnitude;
  console.log("width", w - pageWidth)
    if (w - pageWidth > -100) {
      containerClass.push("full-width");
    }

  if (pos = info.positioning) {
    if (pos.layout == "WRAP_TEXT") {
      if (pos.leftOffset.magnitude > (pageWidth / 2))  {
        containerClass.push("float-right");
      } else {
        containerClass.push("float-left");
      }
      
    } else if (pos.layout == "BREAK_LEFT_RIGHT") {
      containerClass.push("block");
    } else {
      if (pos.layout == "IN_FRONT_OF_TEXT") containerStyles.push(`position:absolute; z-index:1;`);
      if (pos.layout == "BEHIND_TEXT") containerStyles.push(`position:absolute; z-index:-1`);
      if (pos.leftOffset) containerStyles.push(`margin-left:${pos.leftOffset?.magnitude}pt;`);
      if (pos.topOffset) containerStyles.push(`margin-top:${pos.topOffset?.magnitude}pt;`);
    }
  } else {
    containerStyles.push(`display:inline-block`);
  }


  // TODO: This is incorrect because offsets should be based on the original image width, which the API does not provide.
  // https://developers.google.com/docs/api/reference/rest/v1/CropProperties

  let crop = object.imageProperties?.cropProperties;
  if (false) {
    let t = 0 - (crop.offsetTop || 0);
    let l = 0 - (crop.offsetLeft || 0);
    let r = 1 + (crop.offsetRight || 0);
    let b = 1 + (crop.offsetBottom || 0);
    styles.push(`background-position:${l * w}pt ${t * h}pt`)  
    styles.push(`background-size:${(r - l) * w}pt ${(b - t) * h}pt`)  
  }

  let ratio = h/w * 100;
  styles.push(`padding-top:${ratio}%`)
  styles.push(`background-image:url(${object.imageProperties?.contentUri})`)  

  containerStyles.push(`width:${w}pt`)

  return m(containerClass.join("."), {style:containerStyles.join(";")},
    m('div.img', {style:styles.join(";")})
  )
}


function elementForTable(table, doc) {
  let rows = table.tableRows.map(tr => {
    if (tr.tableRowStyle?.minRowHeight?.magnitude < 0.08) return null; // 0.001 min row height is used to hide tables from view mode
    console.log("Row" , tr.tableRowStyle?.minRowHeight?.magnitude, undefined < 0.08)
    let cells = tr.tableCells.map(td => {
      let style = td.tableCellStyle;
      let attrs = {
        colSpan: style.columnSpan,
        rowSpan: style.rowSpan,
      }
      if (style.backgroundColor?.color) attrs.style = "background-color:" + colorForObject(style.backgroundColor?.color?.rgbColor);

      let paragraphEls = td.content.map(c => elementForParagraph(c.paragraph, doc));
      return m('td',attrs, paragraphEls)
    })
    return m('tr', {}, cells);
  })
  return m('table', {}, rows);
}

function expandDocUrl(url) {
  if (!url.startsWith("http")) {
    url = urlForDocInfo({id:url}, true)
  }
  return url;
}

function renderContent(doc, isToc) {
  
  // Create elements for document content
  let body = doc.body
  let docType = isToc ? 'toc' : 'doc';
  console.log("📐 Rendering", docType, [doc.documentId, doc])
  
  if (isToc) doc.isToc = true;

  let children = [];
  let rootEl = m('div.' + docType + '-inner', {})
  let tocEl = isToc ? undefined : m('div.doc-toc', {})
  let heroEl;
  let headingStack = [];
  let currentHeader;

  if (doc.error) {
    rootEl.appendChild(m("div.error", {},
      m('b', {}, ERROR_DESCRIPTIONS[doc.error.details.code]),
      m('br'),
      m('p', {}, doc.error.details.message),
      m('i', {}, doc.error.name, " ",  doc.error.details.code.toString())
      ));
  } else {
    let firstParagraph = false;
    for (const c of doc.body.content) {
      let el;
      if (c.paragraph) {      
        el = elementForParagraph(c.paragraph, doc);
        if (!isToc && !firstParagraph) {
          firstParagraph = true;
          let firstChild = el.children[0];
          if (firstChild && firstChild.classList.contains('img-container') && firstChild.classList.contains('full-width')) {
            heroEl = firstChild;
            heroEl.style.width = '100%';
            heroEl.classList.add('hero')
            el.removeChild(firstChild)
          }
        }
      } else if (c.table) {
        el = elementForTable(c.table, doc);
      }

      let headingId = c.paragraph?.paragraphStyle?.headingId
      let depth = parseInt(c.paragraph?.paragraphStyle?.namedStyleType?.slice(-1));

      if (headingId) {
        let index = headingStack.findIndex(h => h.depth >= depth );
        if (index != -1) headingStack.splice(index);
      }

      let parent = headingStack.length ? headingStack[headingStack.length - 1].el : rootEl;
    
      if (headingId) {
        if (depth) {
          if (tocEl && depth < 2) tocEl.appendChild(m('a', {href:"#" + headingId}, el.innerText))
          let hasBullet = c.paragraph?.bullet;
          el.classList.add("heading")
          let headingChildren = m('div.heading-children', {depth:depth, id:headingId + "-children"});   

          let containerClasses = ['div', 'heading-container'];

          if (hasBullet) containerClasses.push('collapsed')
          containerClasses.push("heading-" +depth);
          el = m(containerClasses.join('.'), {id: headingId + "-container"}, el, headingChildren)
          headingStack.push({depth: depth, el: headingChildren})
        }
      }

      if (el) parent.appendChild(el)
    }


    // Create CSS rules for document styles
    let css = cssForDoc(doc, isToc) // isToc ? cssForDoc(doc) : undefined;
    if (css && css.length) {
        rootEl.appendChild(m('style', {type:'text/css'}, css))
    }
  }

  let docEl = document.getElementById(docType);
  while (docEl.firstChild) docEl.removeChild(docEl.lastChild);



  if (heroEl) {
    docEl.appendChild(heroEl)
    rootEl.classList.add('has-hero')
  }
  // if (tocEl) docEl.appendChild(tocEl);
  docEl.appendChild(rootEl)


  if (isToc) {
    let url;
    document.title = doc.title;
    if (docId.length) {
      url = expandDocUrl(docId)
    } else {
      let links = docEl.querySelectorAll("a[href]");
      for (let link of links) {
        if (urlIsEmbeddable(link.href)) {
          link.classList.add('selected');
          url = link.href
          break;
        }
      }
    
    }
    
    if (url) displayDoc(url);
  } else {
    google.script.url.getLocation(function(location) {
      hash = location.hash
      if (hash.length) {
        console.log("Scrolling to", hash)
        scrollToHeader(hash)
      }
    });
  }
}

function scrollToHeader(hash) {
  if (!hash || !hash.length) return;
  let el = document.getElementById(hash);
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start'});
  //TODO: https://stackoverflow.com/questions/48634459/scrollintoview-block-vs-inline/48635751#48635751
}



function docInfoForUrl(url) {
  let match = url.match(docsRE)
  return match?.groups;
}

function idForUrl(url) {
  if (url) {
    let info = docInfoForUrl(url);
    if (info && info.type == 'document' && info.mode != 'preview') return info.id;
  }
  return url;
}

function urlForDocInfo(doc) {
  let url = "https://docs.google.com/" + (doc.type || 'document') + "/d/";
  url += doc.id + "/" + (doc.mode || 'edit');
  if (doc.hash) url += "#" + doc.hash;
  return url;
  //return `https://docs.google.com/document/d/${doc.id}/${doc.mode}` //|| ''}` + ${doc.header ? '#header=' + header : ''}
}

function createNewToc() {
  document.body.classList.add("new");
  document.getElementById("new-url").focus()
}

function submitNewToc() {
  let link = document.getElementById("new-url").value
  let docInfo = link.startsWith("http") ? docInfoForUrl(link) : {id:link};
  if (docInfo.id) {
    tocId = docInfo.id;
    docId = '';
    docData = {};
    tocData = {};
    pushHistoryState();
    loadDocInline({id: tocId}, true, true)
  }
  document.body.classList.remove("new");
}


document.addEventListener('click', function(e) {
  document.getElementById('menu-button').classList.remove('open');
  let a = e.target.closest('a');
  if (a) {
    let url = a.getAttribute('href');
    if (url) {
      displayDoc(url, e.altKey, true, e.shiftKey)
    }
    e.preventDefault();
    // e.stopPropogation();
    return false;
  } else {
    if (e.target.id) {
      document.getElementById(e.target.id + "-container").classList.toggle('collapsed')
    }

  }
})

function editToc(e) {
  let url = "https://docs.google.com/document/d/" + tocId + "/edit";
  if (e.metaKey || e.ctrlKey) {
    window.open(url, '_blank');
  } else {
    displayDoc(url, true)
  }
}

function editDoc(e) {
  let url = docId;
  if (!url.startsWith("http")) url = urlForDocInfo({id:docId}, true)

  if (e.metaKey || e.ctrlKey) {
    window.open(url, '_blank');
  } else {
    displayDoc(url, true)
  }
}

function fullscreen() {
  let el = document.getElementById('doc-frame');
  el.requestFullscreen();
}

function updateTocSelection(url) {
  let id = idForUrl(url); 
  docId = id;

  let links = document.querySelectorAll("nav a")
  for (let link of links) {
    link.classList.toggle('selected', link.id == id)
    if (link.id == id) {
      while (link = link.parentNode.closest('.heading-container')) {
        link.classList.remove('collapsed');
      }
    }
  }
}

function urlIsEmbeddable(url) {
  if (url.indexOf('docs.google.com') > 0) return true;
  for (let rewrite of URL_REWRITES) {
    if (url.match(rewrite.re)) return true;
  }
  return false;
}

function displayDoc(url, editMode = false, updateHistory = true, ignoreCache = false) {
  console.debug("🖼 Displaying", url)

  if (url.startsWith("#")) return scrollToHeader(url.slice(1))

  let target = 'frame';
  let googleDoc = docInfoForUrl(url);  

  if (googleDoc) {
    if (globalMode == 'edit') editMode = true;
    if (editMode) {
      googleDoc.mode = 'edit';
    } else if (googleDoc.type == "document" && googleDoc.mode != "preview") {
      target = 'inline';
    } else {
      googleDoc.mode = 'preview';
    }
    url = urlForDocInfo(googleDoc)
  } else {
    let rewrite = rewriteUrl(url);
    if (rewrite) {
      url = rewrite;
    } else {
      target = 'blank';
    }
  }

  if (target == 'blank') {
      console.debug("🌐 Opening Tab:", url)
      window.open(url, '_blank');
  } else {
    let frame = document.getElementById('doc-frame');
    if (target == 'inline') {
      loadDocInline(googleDoc, false, ignoreCache);
      document.body.classList.remove('frame');
      frame.src = 'about:blank';
    } else if (target == 'frame') {
      console.debug("🌐 Framing:", url)
      frame.src = url;
      document.body.classList.add('frame');
    }
    updateTocSelection(url, updateHistory);
    if (updateHistory) {
      pushHistoryState()
    }
  }
}

function pushHistoryState() {
  let attrs = {toc:tocId};
  console.log("toc", attrs)
  if (docId && docId.length) attrs.doc = docId;
  console.log("toc", attrs, tocId)
  google.script.history.push({'timestamp': new Date().getTime(), doc:docId}, attrs);
  attrs.title = document.title;
  window.top.postMessage(attrs, '*')
}

function rewriteUrl(url) {
  for (let rewrite of URL_REWRITES) {
    console.log("rplace", url.replace(rewrite.re, rewrite.sub))
    let match =  url.match(rewrite.re)
    if (match) {
      return url.replace(rewrite.re, rewrite.sub)
    }
  }
}

let loadedFonts = {}  
var maybeLoadFont = function(font) {
  if (!font) return false;
  if (document.fonts.check("12px " + font )) return false; // No need to load font.
  if (loadedFonts[font] == 'loaded') return false;  // Font already loaded.
  if (loadedFonts[font] == 'loading') return true;  // Font is loading, just pretend we're loading it.
  

  loadedFonts[font] = 'loading';
  WebFont.load({
      google: { families: [font] },
      timeout: 2000,
      fontactive: function(family, fvd) {
        console.log('💼 Loaded ' + family);
        loadedFonts[family] = 'loaded';
      },
      fontinactive: function(family, fvd) {
        // Error loading font. Fallback
        loadedFonts[family] = 'loaded';
        console.log('⛔️ Failed to load ' + family);
      }
  });
  return true;
}

google.script.history.setChangeHandler(function (e) {
  let state = e.state;
  console.debug("🕘State Changed", state.doc, [e.state, e.parameter, e.location.hash]);
  displayDoc(expandDocUrl(state.doc))
});

if (!tocId.length) {
  loadDocInline({id: tocId}, true)
} else {
  renderContent(tocData, true)
}

</script>
</html>
